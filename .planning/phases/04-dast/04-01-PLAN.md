---
phase: 04-dast
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .github/workflows/dast.yaml
autonomous: true
requirements:
  - DAST-01
  - DAST-02
  - DAST-03
  - DAST-04

must_haves:
  truths:
    - "ZAP baseline scan runs against a live Maxwell's Wallet application instance"
    - "Application health is validated before ZAP scan starts"
    - "ZAP produces HTML and Markdown reports accessible as CI artifacts"
    - "ZAP findings appear in GitHub Security tab with unique category"
    - "DAST workflow completes successfully without blocking builds"
  artifacts:
    - path: ".github/workflows/dast.yaml"
      provides: "DAST workflow orchestrating docker-compose app + ZAP scan"
      min_lines: 80
      exports: ["on: push: branches: [main]", "zaproxy/action-baseline", "docker compose"]
  key_links:
    - from: "dast.yaml"
      to: "docker-compose.dev.yaml"
      via: "docker compose -f docker-compose.dev.yaml up -d"
      pattern: "docker-compose\\.dev\\.yaml"
    - from: "dast.yaml"
      to: "zaproxy/action-baseline"
      via: "GitHub Action call with target http://localhost:3000"
      pattern: "zaproxy/action-baseline"
    - from: "dast.yaml"
      to: "GitHub Security tab"
      via: "github/codeql-action/upload-sarif with category: zap"
      pattern: "category:\\s*zap"
---

<objective>
Create isolated DAST workflow that spins up Maxwell's Wallet in ephemeral Docker Compose environment, validates health, runs OWASP ZAP baseline scan, and uploads findings.

Purpose: Enable runtime vulnerability detection (XSS, CSRF, security headers, etc.) that static analysis cannot catch, completing the security scanning suite.

Output: Standalone dast.yaml workflow integrated into CI pipeline, producing SARIF findings in Security tab and downloadable HTML/Markdown reports.
</objective>

<execution_context>
@/Users/joe/.claude/get-shit-done/workflows/execute-plan.md
@/Users/joe/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-sast/01-01-SUMMARY.md
@docker-compose.dev.yaml
@Dockerfile
@.github/workflows/ci.yaml
@.github/workflows/security.yaml
</context>

<tasks>

<task type="auto">
  <name>Create dast.yaml workflow with Docker Compose app orchestration and ZAP baseline scan</name>
  <files>.github/workflows/dast.yaml</files>
  <action>
Create `.github/workflows/dast.yaml` workflow that:

**Trigger:**
- Push to main branch only (DAST is slow, don't run on PRs)
- Manual dispatch for ad-hoc scans

**Permissions (workflow-level):**
- contents: read
- security-events: write (required for SARIF upload)

**Job: dast**
- runs-on: ubuntu-latest
- timeout-minutes: 20 (app startup + scan can be slow)
- continue-on-error: true (non-blocking per DAST-04)
- Job-level permissions:
  - contents: read
  - security-events: write

**Steps:**

1. **Checkout code**
   - Use actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6

2. **Build and start application**
   - Run: `docker compose -f docker-compose.dev.yaml up -d --build`
   - This spins up frontend (port 3000) and backend (port 3001) per existing docker-compose.dev.yaml

3. **Wait for application health**
   - Run health check loop (pattern from ci.yaml docker job):
     ```bash
     echo "Waiting for services to start..."
     sleep 15

     # Health check backend
     for i in {1..10}; do
       if curl -sf http://localhost:3001/health; then
         echo "Backend is healthy"
         break
       fi
       echo "Backend attempt $i failed, retrying..."
       sleep 3
     done

     # Health check frontend
     for i in {1..10}; do
       if curl -sf http://localhost:3000 > /dev/null; then
         echo "Frontend is healthy"
         break
       fi
       echo "Frontend attempt $i failed, retrying..."
       sleep 3
     done
     ```
   - If health checks fail after retries, show logs and exit 1

4. **Run ZAP baseline scan**
   - Use zaproxy/action-baseline@v0.14.0 (lookup exact SHA before writing)
   - Input: `target: 'http://localhost:3000'`
   - Input: `allow_issue_writing: false` (we upload SARIF manually for category control)
   - Input: `artifact_name: 'zap-scan'`
   - Environment: `ZAP_BASELINE_OPTS: '-a'` (include alpha passive rules)
   - This produces: `report_html.html`, `report_md.md`, `report_json.json`

5. **Convert JSON to SARIF**
   - ZAP action doesn't produce SARIF directly, need to convert
   - Run: `docker run --rm -v $(pwd):/zap/wrk:rw zaproxy/zap-stable:latest zap-cli json-to-sarif -f report_json.json -o zap-report.sarif`
   - OR use a conversion script if zap-cli doesn't support SARIF
   - ALTERNATIVE (simpler): Check if zaproxy/action-baseline has SARIF output option in latest version
   - Research shows: ZAP 2.14+ has native SARIF export via `-J` flag
   - Use: `docker run --rm -v $(pwd):/zap/wrk:rw zaproxy/zap-stable:latest zap-baseline.py -t http://host.docker.internal:3000 -J zap-report.sarif`
   - BUT action-baseline may already handle this - check action source
   - DECISION: Use zaproxy/action-baseline action which handles report generation, then manually convert JSON to SARIF using a converter tool or script

6. **Upload SARIF to GitHub Security tab**
   - Use github/codeql-action/upload-sarif@89a39a4e59826350b863aa6b6252a07ad50cf83e # v4.32.4
   - Input: `sarif_file: zap-report.sarif`
   - Input: `category: zap`
   - Condition: `if: always()` (upload even if ZAP finds issues)

7. **Upload HTML and Markdown reports as artifacts**
   - Use actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v4
   - Input: `name: zap-reports`
   - Input: `path: |
       report_html.html
       report_md.md
     `
   - Input: `retention-days: 30`
   - Condition: `if: always()`

8. **Cleanup**
   - Run: `docker compose -f docker-compose.dev.yaml down -v --remove-orphans`
   - Condition: `if: always()`

**SHA Pinning:**
- All actions MUST use commit SHA format (e.g., `@abc123...` not `@v1`)
- Lookup exact SHAs for:
  - zaproxy/action-baseline (find latest stable version, get SHA)
  - actions/upload-artifact (already known: @b7c566a7)

**SARIF Conversion Strategy:**
ZAP's action-baseline produces JSON by default. Two options:
1. Use separate conversion step (zaproxy/sarif-convert or custom script)
2. Check if action-baseline has native SARIF support via inputs

Research the action before implementing. If no native SARIF, add conversion step using a converter action or script that validates SARIF schema.

**GitHub Step Summary:**
Add summary output showing scan status, finding count, and artifact links for easy access.
  </action>
  <verify>
1. Workflow file exists: `test -f .github/workflows/dast.yaml`
2. YAML syntax valid: `yamllint .github/workflows/dast.yaml` OR `yq eval .github/workflows/dast.yaml > /dev/null`
3. Grep checks:
   - `grep -q "docker compose -f docker-compose.dev.yaml" .github/workflows/dast.yaml`
   - `grep -q "zaproxy/action-baseline" .github/workflows/dast.yaml`
   - `grep -q "category: zap" .github/workflows/dast.yaml`
   - `grep -q "continue-on-error: true" .github/workflows/dast.yaml`
   - `grep -q "actions/checkout@de0fac2e" .github/workflows/dast.yaml`
4. All actions SHA-pinned (no @v tags): `! grep -E "uses:.*@v[0-9]" .github/workflows/dast.yaml`
  </verify>
  <done>
- .github/workflows/dast.yaml exists with all required steps
- Workflow triggers on push to main
- Docker Compose spins up app with health check validation
- ZAP baseline scan runs against http://localhost:3000
- SARIF uploaded to Security tab with category 'zap'
- HTML and Markdown reports uploaded as artifacts
- All actions SHA-pinned following repo conventions
- Workflow is non-blocking (continue-on-error: true)
  </done>
</task>

</tasks>

<verification>
After plan execution, verify:

1. **Workflow structure:**
   - dast.yaml exists and parses without YAML syntax errors
   - Triggers: push to main, workflow_dispatch
   - Single job named 'dast' with timeout-minutes: 20

2. **Security patterns (from Phase 1):**
   - All actions SHA-pinned (no @v1 or @latest tags)
   - Job-level permissions: contents: read, security-events: write
   - continue-on-error: true on job level

3. **Docker orchestration:**
   - Uses docker-compose.dev.yaml (existing file)
   - Health check loop validates backend /health and frontend /
   - Cleanup step runs always (even on failure)

4. **ZAP scan:**
   - zaproxy/action-baseline action present
   - Target: http://localhost:3000
   - SARIF conversion step exists (if not native in action)
   - SARIF upload with category: zap

5. **Artifact upload:**
   - HTML and Markdown reports uploaded with 30-day retention
   - Upload runs always (if: always())

6. **Integration readiness:**
   - Workflow can run independently (no dependencies on other workflows)
   - Follows same pattern as security.yaml (isolated, non-blocking)
</verification>

<success_criteria>
Plan is complete when:

1. **.github/workflows/dast.yaml exists** and passes YAML validation
2. **Workflow triggers on main pushes** (not PRs to keep CI fast)
3. **Docker Compose orchestration** spins up app with health validation
4. **ZAP baseline scan** configured to scan http://localhost:3000
5. **SARIF upload** includes category: zap and uploads to Security tab
6. **Artifacts uploaded** (HTML + Markdown reports, 30-day retention)
7. **All actions SHA-pinned** following repo convention from Phase 1
8. **Non-blocking execution** via continue-on-error: true
9. **File committed** to git with conventional commit message
</success_criteria>

<output>
After completion, create `.planning/phases/04-dast/04-01-SUMMARY.md` with:
- One-liner describing what was built
- Technical implementation details (workflow structure, ZAP configuration)
- Deviations from plan (if any)
- Verification results (YAML validation, grep checks)
- Requirements satisfied (DAST-01 through DAST-04)
- Next steps (Phase 5: Documentation)
</output>
