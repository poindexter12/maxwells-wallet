---
phase: 09-performance-frontend-tests
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/components/widgets/SummaryCards.test.tsx
  - frontend/src/components/widgets/SpendingVelocity.test.tsx
  - frontend/src/components/widgets/AnomaliesPanel.test.tsx
  - frontend/src/components/widgets/BucketPieChart.test.tsx
  - frontend/src/components/widgets/TopMerchantsList.test.tsx
  - frontend/src/components/widgets/TrendsChart.test.tsx
  - frontend/src/components/widgets/SankeyFlowChart.test.tsx
  - frontend/src/components/widgets/SpendingTreemap.test.tsx
  - frontend/src/components/widgets/SpendingHeatmap.test.tsx
  - frontend/src/hooks/useWidgetData.test.ts
autonomous: true
requirements: [TEST-01]

must_haves:
  truths:
    - "Each extracted dashboard widget has unit tests covering render, loading, error, and data states"
    - "Tests use data-testid attributes for element selection (no text-based selectors)"
    - "Tests mock SWR to avoid actual API calls"
    - "Retry button functionality is tested for error states"
  artifacts:
    - path: "frontend/src/components/widgets/SummaryCards.test.tsx"
      provides: "Unit tests for SummaryCards widget"
      min_lines: 50
    - path: "frontend/src/hooks/useWidgetData.test.ts"
      provides: "Unit tests for widget data hooks"
      min_lines: 100
  key_links:
    - from: "frontend/src/components/widgets/*.test.tsx"
      to: "frontend/src/test-ids.ts"
      via: "Import TEST_IDS constant for element selection"
      pattern: "import.*TEST_IDS"
    - from: "frontend/src/hooks/useWidgetData.test.ts"
      to: "swr"
      via: "Mock useSWR hook for isolated testing"
      pattern: "vi.mock.*swr"
---

<objective>
Create comprehensive unit tests for all 9 extracted dashboard widgets covering loading, error, success, and retry states.

Purpose: Satisfy TEST-01 requirement by ensuring widget components are testable and maintainable.
Output: 10 new test files (9 widgets + 1 hooks file) with 100+ test cases total.
</objective>

<execution_context>
@/Users/joe/.claude/agents/gsd-executor.md
@/Users/joe/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-type-safety-dashboard-extraction/07-01-SUMMARY.md
@.planning/phases/08-dashboard-polish-error-handling/08-01-SUMMARY.md
@frontend/src/components/widgets/LazyWidgets.tsx
@frontend/src/components/widgets/SummaryCards.tsx
@frontend/src/components/widgets/types.ts
@frontend/src/hooks/useWidgetData.ts
@frontend/src/test-ids.ts
@frontend/src/components/widgets/SummaryCards.test.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create widget component tests (9 files)</name>
  <files>
    frontend/src/components/widgets/SpendingVelocity.test.tsx
    frontend/src/components/widgets/AnomaliesPanel.test.tsx
    frontend/src/components/widgets/BucketPieChart.test.tsx
    frontend/src/components/widgets/TopMerchantsList.test.tsx
    frontend/src/components/widgets/TrendsChart.test.tsx
    frontend/src/components/widgets/SankeyFlowChart.test.tsx
    frontend/src/components/widgets/SpendingTreemap.test.tsx
    frontend/src/components/widgets/SpendingHeatmap.test.tsx
  </files>
  <action>
For each widget component (excluding SummaryCards which already has tests), create a test file following this pattern:

**Test structure:**
```typescript
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'
import { TEST_IDS } from '@/test-ids'
import { WidgetName } from './WidgetName'

// Mock dependencies
vi.mock('next-intl', () => ({
  useTranslations: () => (key: string) => key
}))

describe('WidgetName', () => {
  it('renders widget with data', () => {
    const mockData = { /* widget-specific mock */ }
    render(<WidgetName data={mockData} />)
    expect(screen.getByTestId(TEST_IDS.WIDGET_NAME)).toBeInTheDocument()
  })

  it('renders loading skeleton when isLoading=true', () => {
    render(<WidgetName isLoading={true} />)
    expect(screen.getByTestId(TEST_IDS.WIDGET_SKELETON)).toBeInTheDocument()
  })

  it('renders error state with retry button when error exists', () => {
    const retryMock = vi.fn()
    render(<WidgetName error={new Error('test')} retry={retryMock} />)
    expect(screen.getByTestId(TEST_IDS.WIDGET_ERROR)).toBeInTheDocument()
    const retryBtn = screen.getByTestId(TEST_IDS.WIDGET_ERROR_RETRY)
    retryBtn.click()
    expect(retryMock).toHaveBeenCalledOnce()
  })

  it('renders null when data is null and not loading', () => {
    const { container } = render(<WidgetName data={null} />)
    expect(container.firstChild).toBeNull()
  })
})
```

**Widget-specific considerations:**
- SpendingVelocity: mock daily_average, days_remaining, is_on_track
- AnomaliesPanel: mock anomalies array with transaction details
- BucketPieChart: mock bucket data with name/value/count
- TopMerchantsList: mock merchants array with merchant/amount/count
- TrendsChart: mock trends array with date/amount
- SankeyFlowChart: mock nodes/links for flow diagram
- SpendingTreemap: mock hierarchical data
- SpendingHeatmap: mock grid data with dates/amounts

Use existing SummaryCards.test.tsx as reference pattern. Keep tests focused on rendering logic, not business logic.
  </action>
  <verify>
    Run `make test-frontend` — all widget tests pass
  </verify>
  <done>
    9 widget test files exist, all tests pass, coverage includes loading/error/success/retry states
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useWidgetData hooks tests</name>
  <files>
    frontend/src/hooks/useWidgetData.test.ts
  </files>
  <action>
Create comprehensive tests for all widget data hooks using Vitest and mock SWR:

**Test coverage:**
1. **useDashboardParams** — returns correct params from DashboardContext, handles null currentDashboard
2. **useSummaryData** — fetches monthly/annual summary based on scale, includes dashboardId in SWR key
3. **useMonthOverMonthData** — only fetches for monthly scale, returns null for yearly
4. **useSpendingVelocityData** — same scale handling
5. **useAnomaliesData** — same scale handling
6. **useTrendsData** — includes filters in query string
7. **useTopMerchantsData** — excludes merchant filter (doesn't make sense), includes bucket/account filters
8. **useSankeyData, useTreemapData, useHeatmapData** — include all filters
9. **useBucketData** — derives from summary data

**Mock pattern:**
```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { renderHook } from '@testing-library/react'
import { useSummaryData } from './useWidgetData'

// Mock SWR
vi.mock('swr', () => ({
  default: vi.fn(() => ({ data: null, error: null, isLoading: false, mutate: vi.fn() }))
}))

// Mock toast
vi.mock('sonner', () => ({
  toast: { error: vi.fn() }
}))

// Mock DashboardContext
vi.mock('@/contexts/DashboardContext', () => ({
  useDashboard: vi.fn(() => ({
    currentDashboard: {
      id: 1,
      date_range: { start_date: '2024-01-01', end_date: '2024-01-31' },
      date_range_type: 'mtd'
    }
  }))
}))

describe('useSummaryData', () => {
  it('constructs monthly endpoint when isMonthlyScale=true', () => {
    const { result } = renderHook(() => useSummaryData())
    // Assert SWR was called with correct endpoint
  })

  it('includes dashboardId in SWR key for cache isolation', () => {
    // Assert SWR key is [endpoint, dashboardId]
  })

  it('shows toast on error', () => {
    // Mock SWR to return error, assert toast.error called
  })
})
```

Test all 9 widget hooks + useDashboardParams. Focus on:
- Correct endpoint construction
- dashboardId in SWR key
- Filter query string building
- Scale-based conditional fetching
- Toast error handling
  </action>
  <verify>
    Run `make test-frontend` — useWidgetData.test.ts passes with 20+ test cases
  </verify>
  <done>
    useWidgetData.test.ts exists covering all hooks, tests pass, dashboardId cache isolation verified
  </done>
</task>

</tasks>

<verification>
- [ ] All 9 widget test files exist and pass
- [ ] useWidgetData.test.ts exists and passes
- [ ] No test uses text content for element selection (all use data-testid)
- [ ] Total test count increases by 50+ tests
- [ ] `make test-frontend` passes with improved coverage
- [ ] Build succeeds: `make build-frontend`
</verification>

<success_criteria>
1. All 9 extracted dashboard widgets have unit tests
2. All widget data hooks have unit tests
3. Tests cover loading, error, success, and retry states
4. Tests use data-testid attributes exclusively
5. TEST-01 requirement satisfied
6. Frontend test coverage maintained or improved
</success_criteria>

<output>
After completion, create `.planning/phases/09-performance-frontend-tests/09-02-SUMMARY.md`
</output>
