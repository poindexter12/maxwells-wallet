---
phase: 08-dashboard-polish-error-handling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/package.json
  - frontend/src/app/layout.tsx
  - frontend/src/components/ErrorBoundary.tsx
  - frontend/src/hooks/useWidgetData.ts
  - frontend/src/components/widgets/LazyWidgets.tsx
autonomous: true
requirements: [ERR-01, ERR-02, ERR-03, ERR-04]

must_haves:
  truths:
    - "User sees toast notification when any API call fails"
    - "User can retry failed API calls via a retry button"
    - "React error boundary catches rendering crashes and shows recovery UI"
    - "Loading skeleton placeholders display while widgets fetch data"
  artifacts:
    - path: "frontend/src/components/ErrorBoundary.tsx"
      provides: "React error boundary with recovery UI"
      min_lines: 50
    - path: "frontend/src/app/layout.tsx"
      provides: "Toaster provider and ErrorBoundary wrapper"
      contains: "Toaster"
    - path: "frontend/src/hooks/useWidgetData.ts"
      provides: "SWR error handling with toast notifications"
      contains: "toast.error"
  key_links:
    - from: "frontend/src/hooks/useWidgetData.ts"
      to: "sonner toast"
      via: "toast.error() on SWR error state"
      pattern: "toast\\.error"
    - from: "frontend/src/components/widgets/LazyWidgets.tsx"
      to: "mutate (retry)"
      via: "retry button calls SWR mutate"
      pattern: "mutate\\(\\)"
    - from: "frontend/src/app/layout.tsx"
      to: "ErrorBoundary"
      via: "wraps children"
      pattern: "<ErrorBoundary>"
---

<objective>
Implement comprehensive error handling infrastructure for dashboard and widgets

Purpose: Users need clear feedback when API calls fail and ability to recover without full page refresh
Output: Error boundary component, toast notifications integrated with SWR, retry buttons, verified skeleton loading states
</objective>

<execution_context>
@/Users/joe/.claude/get-shit-done/workflows/execute-plan.md
@/Users/joe/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONCERNS.md
@.planning/codebase/CONVENTIONS.md

# Phase 7 context - SWR and widget structure
@.planning/phases/07-type-safety-dashboard-extraction/07-01-SUMMARY.md

# Existing error translation infrastructure
@frontend/src/hooks/useApiError.ts

# SWR hooks to enhance with error handling
@frontend/src/hooks/useWidgetData.ts

# Widget skeleton already exists from Phase 7
@frontend/src/components/widgets/WidgetSkeleton.tsx
@frontend/src/components/widgets/LazyWidgets.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install sonner and create ErrorBoundary component</name>
  <files>
    frontend/package.json
    frontend/src/components/ErrorBoundary.tsx
    frontend/src/app/layout.tsx
  </files>
  <action>
Install sonner toast library:
```bash
cd frontend && npm install sonner
```

Create ErrorBoundary component at frontend/src/components/ErrorBoundary.tsx:
- Use React 18 error boundary pattern (class component with static getDerivedStateFromError and componentDidCatch)
- Capture error message and component stack
- Show recovery UI with: error message, "Something went wrong" heading, "Try again" button that calls window.location.reload()
- Use TEST_IDS.ERROR_BOUNDARY constant for data-testid attributes
- Style with Tailwind: centered card with red border, icon, and primary button
- Log error details to console for debugging

Add ErrorBoundary wrapper in frontend/src/app/layout.tsx:
- Import ErrorBoundary and Toaster from sonner
- Wrap children in ErrorBoundary
- Add Toaster component at root level (position="top-right", richColors)
- Place ErrorBoundary inside the internationalization provider (NextIntlClientProvider) so translations work in error UI

Reference existing error translation infrastructure (useApiError.ts) for consistent error messaging patterns.
  </action>
  <verify>
```bash
cd frontend
npm list sonner  # Should show installed version
grep -q "ErrorBoundary" src/app/layout.tsx && echo "ErrorBoundary integrated"
grep -q "Toaster" src/app/layout.tsx && echo "Toaster integrated"
test -f src/components/ErrorBoundary.tsx && echo "ErrorBoundary component exists"
```
  </verify>
  <done>
- sonner package installed in frontend/package.json
- ErrorBoundary component exists with recovery UI
- layout.tsx wraps children in ErrorBoundary and includes Toaster
- Error boundary uses test IDs from TEST_IDS constant
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate toast notifications with SWR error states</name>
  <files>
    frontend/src/hooks/useWidgetData.ts
    frontend/src/components/widgets/LazyWidgets.tsx
  </files>
  <action>
Update frontend/src/hooks/useWidgetData.ts to add toast error notifications:
- Import toast from 'sonner' and useApiError hook
- In each typed SWR hook (useSummaryData, useTrendsData, etc.), add useEffect to watch error state
- When error changes to non-null, call toast.error() with translated message from useApiError
- Pattern:
  ```typescript
  const { translateFetchError } = useApiError()
  useEffect(() => {
    if (error) {
      toast.error('Failed to load widget data')
    }
  }, [error])
  ```
- Apply to all 9 widget hooks in the file

Update frontend/src/components/widgets/LazyWidgets.tsx to add retry buttons:
- Import { mutate } from 'swr'
- For each LazyWidget component that shows error state, add retry button
- Button calls mutate(key) to refetch the data
- Use existing error state rendering, enhance with retry button
- Style retry button with Tailwind: secondary button style, icon optional
- Use TEST_IDS for retry button data-testid attributes

Keep existing SWR configuration (revalidateOnFocus: false, etc.) — only add error handling layer.
  </action>
  <verify>
```bash
cd frontend
grep -q "toast.error" src/hooks/useWidgetData.ts && echo "Toast notifications integrated"
grep -q "mutate" src/components/widgets/LazyWidgets.tsx && echo "Retry buttons integrated"
make lint  # Should pass
make build-frontend  # Should compile successfully
```
  </verify>
  <done>
- All SWR hooks in useWidgetData.ts show toast notification on error
- All LazyWidget components have retry buttons that call mutate
- Build and lint pass without errors
- Test IDs added to retry buttons for E2E testing
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify skeleton loading states display correctly</name>
  <files>
    frontend/src/components/widgets/LazyWidgets.tsx
  </files>
  <action>
Review and verify frontend/src/components/widgets/LazyWidgets.tsx:
- Confirm each LazyWidget component shows WidgetSkeleton when isLoading is true
- Pattern should already exist from Phase 7: `if (isLoading) return <WidgetSkeleton />`
- Verify SWR's isLoading state is correctly destructured from each hook
- If any widget is missing skeleton handling, add it following the existing pattern

Check that WidgetSkeleton component (from Phase 7) has proper styling:
- Should render placeholder UI matching widget dimensions
- Should have subtle animation (shimmer or pulse)
- Should be clearly distinguishable from loaded content

No changes expected if Phase 7 implementation is correct — this is verification with minor fixes if needed.
  </action>
  <verify>
```bash
cd frontend
# Verify all LazyWidgets use WidgetSkeleton for loading state
grep -c "isLoading.*WidgetSkeleton" src/components/widgets/LazyWidgets.tsx  # Should be >= 9 (one per widget)
make test-frontend  # All tests should pass
```
  </verify>
  <done>
- All LazyWidget components correctly show WidgetSkeleton during isLoading
- WidgetSkeleton has proper styling and animation
- No regression in existing widget loading behavior
- All frontend tests pass
  </done>
</task>

</tasks>

<verification>
1. **ERR-01 (Toast notifications):** Trigger API error (kill backend, reload dashboard) → user sees toast notification
2. **ERR-02 (Retry buttons):** Click retry button on error state → API call retries, success clears error
3. **ERR-03 (Error boundary):** Force rendering error (modify widget to throw) → error boundary catches and shows recovery UI
4. **ERR-04 (Loading skeletons):** Reload dashboard → skeletons display while widgets fetch data

Run full quality gate:
```bash
make lint           # Must pass
make build-frontend # Must compile
make test-frontend  # All tests pass
make test-e2e       # E2E tests pass (dashboard-tabs.spec.ts still has skip for DASH-03)
```
</verification>

<success_criteria>
1. User sees toast notification with descriptive message when any API call fails
2. User can click retry button on failed widgets to refetch data
3. React error boundary catches component rendering crashes and shows recovery UI with reload button
4. Loading skeletons display during initial widget data fetching
5. All quality gates pass (lint, build, tests)
6. No new TypeScript any assertions introduced
</success_criteria>

<output>
After completion, create `.planning/phases/08-dashboard-polish-error-handling/08-01-SUMMARY.md`
</output>
